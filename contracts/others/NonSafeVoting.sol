// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./NonSafeTokenTimelockProxy.sol";

/**
 * @dev DAO Voting contract
 */
contract NonSafeVoting {
    // The contract used for votes weights
    address public _tokenTimelocks;

    // The number of votes quantity able to validate a proposal
    uint256 public _minQuorum;

    // Minimum time before execution
    uint256 public _minDebatingPeriod;

    // Minimum time difference between a lock time and a debate execution
    uint256 public _minDifferenceLockPeriod;

    // List of Proposals for Artifact generated by assignee
    mapping(uint256 => Proposal) public _proposals;

    // Number of Proposals
    uint256 public _numProposals;

    /**
     * Structure used to manipulate a proposal
     */
    struct Proposal {
        string metadata;
        uint256 executionDate;
        uint256 quorum;
        mapping(uint256 => Suggestion) suggestions;
        uint256 numSuggestions;
        mapping(address => Vote) votes;
        bool executed;
        bool proposalPassed;
        uint256 finalResult;
    }

    /**
     * Structure used to manipulate a suggestion
     */
    struct Suggestion {
        address advisor;
        string metadata;
        mapping(uint256 => address) votes;
        uint256 numVotes;
        uint256 votesQuantity;
    }

    /**
     * Structure used to manipulate a vote of a single member
     */
    struct Vote {
        bool voted;
        uint256 suggestionID;
        uint256 voteID;
    }

    /**
     * Event for a proposal added
     */
    event ProposalAdded(
        uint256 proposalID,
        string metadata,
        uint256 executionDate
    );

    /**
     * Event for a suggestion added
     */
    event SuggestionAdded(
        uint256 proposalID,
        uint256 suggestionID,
        address advisor,
        string metadata
    );

    /**
     * Event for a vote
     */
    event Voted(
        uint256 proposalID,
        uint256 suggestionID,
        address voter,
        uint256 voteWeight
    );

    /**
     * Event for a vote changed
     */
    event VoteChanged(
        uint256 proposalID,
        uint256 oldSuggestionID,
        uint256 newSuggestionID,
        address voter,
        uint256 voteWeight
    );

    /**
     * Event for an execution
     */
    event ProposalExecuted(
        uint256 proposalID,
        bool proposalPassed,
        uint256 finalResult
    );

    /**
     * @dev Modifier to allow only operating with existing suggestion
     */
    modifier suggestionExists(uint256 proposalID, uint256 suggestionID) {
        require(proposalID < _numProposals);
        require(suggestionID < _proposals[proposalID].numSuggestions);
        _;
    }

    /**
     * @param tokenTimelockProxy Address of the token timelock proxy used for weight
     * @param minimumQuorumForProposals Number used to validate a vote in the execution
     * @param minTimeForDebate minimum time required before execution
     */
    constructor(
        address tokenTimelockProxy,
        uint256 minimumQuorumForProposals,
        uint256 minTimeForDebate,
        uint256 minDifferenceLockPeriod_
    ) {
        _tokenTimelocks = tokenTimelockProxy;
        _minQuorum = minimumQuorumForProposals;
        _minDebatingPeriod = minTimeForDebate;
        _minDifferenceLockPeriod = minDifferenceLockPeriod_;
    }

    /**
     * @dev Add Proposal
     */
    function submitProposal(
        string memory metadata,
        uint256 debatingPeriod,
        uint256 quorum
    ) public returns (uint256 proposalID) {
        require(
            debatingPeriod >= _minDebatingPeriod,
            "Less than the minimum debating period"
        );
        require(quorum >= _minQuorum, "Less than the minimum quorum");
        uint256 executionDate = block.timestamp + debatingPeriod;
        require(
            checkLockedTokens(
                msg.sender,
                executionDate + _minDifferenceLockPeriod
            ) > 0,
            "Not enough tokens locked"
        );

        proposalID = _numProposals++;
        Proposal storage p = _proposals[proposalID];
        p.metadata = metadata;
        p.executionDate = executionDate;
        p.quorum = quorum;

        emit ProposalAdded(proposalID, metadata, executionDate);

        return proposalID;
    }

    /**
     * @dev Add Suggestion
     */
    function submitSuggestion(uint256 proposalID, string memory metadata)
        public
        returns (uint256 suggestionID)
    {
        require(proposalID < _numProposals, "Wrong roposal id");
        Proposal storage p = _proposals[proposalID];
        require(
            !p.executed && block.timestamp < p.executionDate,
            "Proposal executed or to be executed"
        );
        require(
            checkLockedTokens(
                msg.sender,
                p.executionDate + _minDifferenceLockPeriod
            ) > 0,
            "Not enough tokens locked"
        );

        suggestionID = p.numSuggestions++;
        Suggestion storage s = p.suggestions[suggestionID];
        s.advisor = msg.sender;
        s.metadata = metadata;

        emit SuggestionAdded(proposalID, suggestionID, msg.sender, metadata);

        return suggestionID;
    }

    /**
     * @dev Log a vote for a proposal
     */
    function vote(uint256 proposalID, uint256 suggestionID)
        public
        returns (uint256 voteID)
    {
        require(proposalID < _numProposals);
        Proposal storage p = _proposals[proposalID];
        require(!p.executed && block.timestamp <= p.executionDate);
        uint256 voteWeigth =
            checkLockedTokens(
                msg.sender,
                p.executionDate + _minDifferenceLockPeriod
            );
        require(voteWeigth > 0, "Not enough tokens locked");
        Vote storage v = p.votes[msg.sender];
        require(!v.voted);
        require(suggestionID < p.numSuggestions);

        Suggestion storage s = p.suggestions[suggestionID];
        v.voted = true;
        v.suggestionID = suggestionID;
        v.voteID = s.numVotes++;
        s.votes[v.voteID] = msg.sender;
        s.votesQuantity += voteWeigth;

        emit Voted(proposalID, suggestionID, msg.sender, voteWeigth);

        return v.voteID;
    }

    /**
     * @dev Change vote for a proposal
     */
    function changeVote(uint256 proposalID, uint256 newSuggestionID)
        public
        returns (uint256 voteID)
    {
        require(proposalID < _numProposals);
        Proposal storage p = _proposals[proposalID];
        require(!p.executed && block.timestamp <= p.executionDate);
        uint256 voteWeigth =
            checkLockedTokens(
                msg.sender,
                p.executionDate + _minDifferenceLockPeriod
            );
        require(voteWeigth > 0, "Not enough tokens locked");
        Vote storage v = p.votes[msg.sender];
        require(v.voted);
        require(v.suggestionID != newSuggestionID);
        require(newSuggestionID < p.numSuggestions);

        uint256 oldSuggestionID = v.suggestionID;
        v.suggestionID = newSuggestionID;
        Suggestion storage oldSuggestion = p.suggestions[oldSuggestionID];
        Suggestion storage newSuggestion = p.suggestions[newSuggestionID];

        uint256 index = v.voteID;
        if (oldSuggestion.numVotes > 1) {
            address last = oldSuggestion.votes[oldSuggestion.numVotes - 1];
            oldSuggestion.votes[index] = last;
            Vote storage vLast = p.votes[last];
            vLast.voteID = index;
        }
        oldSuggestion.numVotes--;
        oldSuggestion.votesQuantity -= voteWeigth;

        v.voteID = newSuggestion.numVotes++;
        newSuggestion.votes[v.voteID] = msg.sender;
        newSuggestion.votesQuantity += voteWeigth;

        emit VoteChanged(
            proposalID,
            oldSuggestionID,
            newSuggestionID,
            msg.sender,
            voteWeigth
        );

        return v.voteID;
    }

    /**
     * @dev Finish vote, count the votes proposal and execute
     */
    function executeProposal(uint256 proposalID) public {
        require(proposalID < _numProposals);
        Proposal storage p = _proposals[proposalID];
        require(!p.executed && block.timestamp >= p.executionDate);

        p.executed = true;
        uint256 tmpMax = 0;
        uint256 tmpTotal = p.suggestions[tmpMax].votesQuantity;
        for (uint256 i = 1; i < p.numSuggestions; i++) {
            tmpTotal += p.suggestions[i].votesQuantity;
            if (
                p.suggestions[i].votesQuantity >
                p.suggestions[tmpMax].votesQuantity
            ) {
                tmpMax = i;
            }
        }

        if (tmpTotal > p.quorum) {
            p.proposalPassed = true;
            p.finalResult = tmpMax;
        } else {
            p.proposalPassed = false;
        }

        emit ProposalExecuted(proposalID, p.proposalPassed, p.finalResult);
    }

    function checkLockedTokens(address locker, uint256 minDate)
        public
        view
        returns (uint256)
    {
        uint256 lockedTokens = 0;
        (uint256[] memory releaseTimes, uint256[] memory balances) =
            NonSafeTokenTimelockProxy(_tokenTimelocks)
                .checkLockerReleaseTimesAndBalances(locker);
        for (uint256 i = 0; i < releaseTimes.length; i++) {
            if (releaseTimes[i] >= minDate) {
                lockedTokens += balances[i];
            }
        }
        return lockedTokens;
    }

    /**
     * @return true if a proposal is executed
     */
    function isExecuted(uint256 proposalID) public view returns (bool) {
        require(proposalID < _numProposals);
        return _proposals[proposalID].executed;
    }

    /**
     * @return Get proposal final result
     */
    function getProposalFinalResult(uint256 proposalID)
        public
        view
        returns (uint256)
    {
        require(proposalID < _numProposals);
        require(isExecuted(proposalID), "Proposal not yet executed");

        return _proposals[proposalID].finalResult;
    }

    /**
     * @return Proposal metadata
     */
    function getProposalMetadata(uint256 proposalID)
        public
        view
        returns (string memory)
    {
        require(proposalID < _numProposals);

        return _proposals[proposalID].metadata;
    }

    /**
     * @return Proposal suggestion metadata
     */
    function getProposalSuggestionMetadata(
        uint256 proposalID,
        uint256 suggestionID
    )
        public
        view
        suggestionExists(proposalID, suggestionID)
        returns (string memory)
    {
        return _proposals[proposalID].suggestions[suggestionID].metadata;
    }

    /**
     * @return Number of proposals suggestions
     */
    function numberOfProposalSuggestions(uint256 proposalID)
        public
        view
        returns (uint256)
    {
        require(proposalID < _numProposals);
        return _proposals[proposalID].numSuggestions;
    }

    /**
     * @return Number of votes of proposal suggestion
     */
    function getProposalSuggestionVotes(
        uint256 proposalID,
        uint256 suggestionID
    ) public view suggestionExists(proposalID, suggestionID) returns (uint256) {
        return _proposals[proposalID].suggestions[suggestionID].numVotes;
    }

    /**
     * @return Quantity of votes of proposal suggestion
     */
    function getProposalSuggestionVotesQuantity(
        uint256 proposalID,
        uint256 suggestionID
    ) public view suggestionExists(proposalID, suggestionID) returns (uint256) {
        return _proposals[proposalID].suggestions[suggestionID].votesQuantity;
    }

    /**
     * @return true if account voted for suggestionID in proposalID
     */
    function hasVotedFor(
        address account,
        uint256 proposalID,
        uint256 suggestionID
    ) public view suggestionExists(proposalID, suggestionID) returns (bool) {
        return
            _proposals[proposalID].votes[account].suggestionID == suggestionID;
    }
}
